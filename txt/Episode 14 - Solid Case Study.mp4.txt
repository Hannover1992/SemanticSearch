 ðŸŽµðŸŽµðŸŽµ  Hi, I'm Amanda.  Hi, I'm Princess.  Hi, I'm Alexis.  Hi, I'm Lucas.  Welcome to another episode of Clean Code.  Clean Coated  Clean Coated  Your Master Potatoes  To begin a journey of  In this episode  Episode  Exciting  Mmm  Mmm  By Uncle Bob  Uncle Bob  Uncle Bob  Enjoy  Uncle Bob  Enjoy  Oh hi, glad you're here.  Um, grab a seat.  do really soon. We've got to finish writing it up, so why don't we sit down and start on the design.  By the way, it's a really good thing that we studied all those solid principles together.  That's going to make this design a lot easier and a lot better.  I suggest we begin by enumerating all the use cases, or at least as many as we can think of.  Then we can assemble them into a use case driven architecture. We can choose a couple of use cases  their design and in fact we can implement them to check the design and  then we will repeat that process over and over again until the design and the  implementation are complete so are you ready get yourself a cup of coffee pull  up a chair because it's time for us to jump into the payroll system case study  of the solid principles  Okay, so why don't we look at those requirements again?  It's a good thing we recorded them back in Episode 7.  So let's listen to the first part of that recording again,  check out the requirements, and see if we can list all the use cases.  Some of our employees work hourly, and they get paid an hourly rate.  And, like, they have to submit time cards at the end of every day.  Because we need to know whether or not they worked more than 8 hours a day or 40 hours  a week, because if they did, well then they get paid time and a half.  Okay, now there's a couple of use cases we can talk about.  We've got to be able to add employees, and that of course means we have to be able to  delete them and change them.  We also need to add time cards and pay all the employees.  And then there are data elements to consider.  There's the employee data element and there's the time card data element.  Some employees work in sales and they get a commission rate plus base salary and every  week they have to submit their sales receipts.  On the first and the third Friday they get paid but it's a base rate plus their commission.  Alright, well there's at least two different kinds of employees here.  entity a sales receipt and that implies a use case, a new use case, add sales receipt. These  data entities clearly have some data in them. The hourly employee has an hourly rate. The  commissioned employee has a base pay and a commission rate. The time card has a date and  a number of hours worked and the sales receipt has a date and the amount sold. The rest of the  of the month, then they just get their regular salary.  Okay, so there's also an exempt employee who gets paid a salary.  We'll call him a salaried employee.  Did you notice that all three of these different kinds of employees get paid on a different  schedule?  The hourly employee gets paid weekly.  The commissioned employee gets paid bi-weekly.  The salaried employee gets paid monthly.  three ways to get paid. Like they can pick up their paycheck by the Paymaster or we could  mail it to them or it could just be direct deposited into their account.  We'll capture the three different ways to get paid in a new entity called a pay disposition.  The pay disposition has three different values, each of which has its own internal structure  Notice that what we've been doing here is listening to the customer and capturing the data implied by the customer's words.  This is a very old practice.  We're building a data dictionary.  We're building up the data that supports the requirements.  Notice also that we haven't been changing the use cases much.  Almost everything we've been done has been done to the data.  but we haven't been discussing any of the operations.  So although the use cases really are getting more complicated by the minute,  that's because the data is getting more complicated,  not because the use case operations are changing.  This next one is really tricky, so I've got notes.  Some employees belong to a union,  and the union deducts their dues out of their paychecks.  Ah, and they might assess certain charges, service charges, from time to time.  Anyway, these charges are submitted to the payroll system at the end of the pay period,  and it will be deducted out of the paychecks of the next week.  Union membership seems to be a Boolean.  That's pretty easy to represent in our data dictionary.  And we also have to put the service charge into our dictionary, too.  That's no problem.  We'll change the employee so that it holds on to the union membership.  Oh, and we've got a new use case.  Add service charge.  a lot of data here. After all, where is the description of the service charge, or  the description of the time card, or anything like that? In a more elaborate  case study, we'd be adding all of these elements, but we only have an hour, so we  need to keep things short. Besides, this is an agile project, and so what we're  seeing here are the features of just the first iteration. Other iterations would  add those other data elements. That data dictionary is getting awfully scruffy,  There's a lot of redundant data in there.  We can improve it by gathering all the common elements together  and then creating employee subtypes that define the differences.  This makes the data dictionary a lot simpler, a lot more efficient,  and it also implies how the eventual structure of this system might occur.  So this is a web-based system,  and they'll do stuff like add employees or modify assistant employees and add paychecks  and delete old employees and sales receipts and service charges and all that kind of thing.  We want it to be a web 2.0 system with a drag and drop feature and all that cool Ajax stuff.  We've heard about Ajax and think it's really cool and think it'll give us a competitive  Oh, we also think this should be a service-oriented architecture.  We heard about SAWA and really think it's the way to go.  We also heard that there's a standard database schema and a service protocol that is developed  for payroll systems, developed by ISOCIPA.  Oh, and let me tell you, we need to have these done by next month, and we've heard about  the agile practices and methods that they make you go faster, so we want you to use  those, okay?  Oh my god, I thought we sent these people off on the first spaceship.  All of that stuff was architecturally irrelevant.  I didn't mention any new use cases. This was all fluff around the outside.  We can defer this until much, much later.  So now we're going to start a design session.  We're going to do that by breaking the requirements down into use cases.  And then we'll break the use cases down into a bunch of classes.  And as we do this, you'll note that the design we develop will be slightly different  and the design that's in my book here, Agile Software Development Principles, Patterns, and Practices.  The differences aren't significant, but they are interesting.  I thought you'd enjoy seeing a slightly different twist on some of the design options.  So let's begin with the single responsibility principle.  Who are the actors in this application?  To whom do our modules owe their allegiance?  One of these actors runs the system.  These are the guys who sit at the UI and they add employees and change employees  and they add time cards and sales receipts and service charges.  We'll call this actor Operations.  Another actor sets the policy and rules for how employees get paid.  control over how much the employees get paid and when they get paid.  Let's call this actor Policy.  Still another actor is responsible for deciding when to deduct union dues, how to charge for  union service charges, and the whole issue of union membership.  We'll call this actor Union.  to one and only one actor.  That's going to be tricky,  because each of the use cases has a UI component  that is responsible to operations,  and each of the use cases deals with data and operations  that the other actors are interested in.  So let's break these use cases down a bit  and see if we can isolate them into modules  that have a single responsibility.  We'll begin with the AddEmployee use case.  employee types, each with their own data, but each that shares common data between them.  We can divide the use cases into an abstract use case that deals with all the common issues,  and then three extending use cases that deal with the specific issues for each employee.  Notice that we're beginning to see a separation of the responsibilities here. The union responsibility  seems to be concerned only with the abstract use case. Of course, operations is involved  but we'll break that dependency once we separate the UI from the use cases.  Our real concern here is that the policy actor and the union actor  are both involved with the abstract use case.  We can break that codependency by extracting a new use case out of the abstract use case.  We'll call this new use case the set union membership use case,  and we'll have the abstract use case use it.  the policies and the union actors nicely. Notice also that I've eliminated the  operations use case from the diagram. That's because we're about to break the  dependency on the UI. So here we've translated the use cases into real  classes and real data structures. The blue rectangles up at the top are data  structures created by the UI and passed down to the rectangles at the bottom, the  use case operations. These classes and data structures are codable and their  responsibilities have been separated to the point where they all conform to the  single responsibility principle.  So before we continue I'd like to talk to you a little bit about these  diagrams I've been drawing. You might be wondering if I usually draw diagrams  Well, the answer to that is, no, I don't usually draw diagrams like this.  The reason I'm drawing them now in this episode  is so that I can communicate my thought process to you.  For an application of this size where I'd usually be working alone,  I'd probably just write the code and deal with the design issues as they happen.  On the other hand, if I were working on a team with a bunch of guys,  a few diagrams on a whiteboard.  They'd probably be class diagrams.  They wouldn't be as elaborate or detailed or complete  as the ones I'm drawing for you.  They'd just be enough so that everybody on the team  knew what was going on and were all on the same page.  So when would I draw diagrams this elaborate  and this complete?  Well, you're seeing the answer to that right now.  I would use this much effort in a diagram  to communicate the details of my thought process to someone. But for any other purpose, diagrams  this elaborate are a waste of time and effort. But don't diagrams like this act as a good  historical record? Wouldn't they be helpful for new people to figure out what the design  was all about? Not in your life! I mean, diagrams like these are recording very short-term decisions  out of date very rapidly. Within a matter of weeks there will be decisions made that  completely overturn the ideas in here, and unless these documents are continuously maintained,  they're going to rot and become obsolete, and no one ever has the time to actually maintain  diagrams as elaborate and detailed as these. So now let's get back to the design. Some of you  that I went to all the trouble of creating a brand new data structure and a brand new use case  just to solve the union membership issue.  You could easily accuse me of premature optimization  or of violating Yagni.  You ain't gonna need it.  But that's not what I'm doing.  By identifying the actors and then separating out the modules  so that each module is responsible to one and only one actor,  All I'm doing is creating the architectural framework upon which to hang the use cases.  I've already identified the actors, so I know I need to partition the modules.  So there's nothing premature about this partitioning.  I'm not violating the Agni here.  Now again, I wouldn't really have been drawing all these formal diagrams.  What I would have been doing instead is maybe scratching some diagrams on a whiteboard  code. The design decisions you've seen me make in diagrams I very likely would  have made in code instead and the refactoring that we have done in  diagrams I probably would have done in code. The thought process you're seeing  hasn't changed it's just that I'm using a different medium to express it.  If we put our current design into a slightly larger context, we'll see that we've already  got an open-closed issue brewing.  Consider the addEmployeeController, which is part of the UI.  Assume that it has detected that it's supposed to create an hourly employee.  So it creates the request data structure, addHourlyEmployeeRequest, and it gets the  and then it passes that data structure into the use case, calling the execute method.  That controller depends on the details of the data structure and the details of the use case.  If I attempt to extend that data structure or that use case in a way that shouldn't really affect the controller,  I'm still going to have to recompile and redeploy that controller.  or some other kind of administrative variable to the data structure. Well, that  will cause the controller to recompile. Or let's say that I change the internal  representation of the hourly rate from double to an integer that represents  tenths of hours. Once again, that will force the controller to be recompiled  and redeployed. We can fix this by decoupling the data structures and the  by using builders, factories, and interfaces.  For example, we could create the request builder interface.  And in this interface, we would put methods that build each individual data structure.  The implementation of that interface would actually do the building,  and it would return those data structures under the degenerate type request.  case. The implementation of that interface would create those use cases,  but would return them as the interface use case. The use case interface and the  request data type, that degenerate type, would both be used by the controller to  execute the use case. This solves the open-closed issue, or at least it  mitigates it. There are now changes that I can make to the data structures that  If those changes don't affect the signatures of the methods on the request builder, the controllers will remain unaffected.  And the same is true of the use cases.  There are changes that I can now make to the use cases,  and so long as those changes don't affect the signatures of the methods in the use case factory,  the controller will remain unaffected.  You might be worried that this is too many classes,  but when you stop to think about it, there's only one request builder and one use case factory in the system,  there really aren't that many more classes than we had before.  And then imagine if this system were done in Ruby.  If it were done in Ruby, the interfaces would disappear.  So there'd be even fewer classes to worry about.  But isn't this just too much mechanism?  Aren't we just inventing gobs and gobs of useless code?  In a static sense, it's true that there's a little bit more code here.  But there's no more executable code than before.  to different isolated places.  We still have to create the data structure.  We still have to create the use case.  We still have to call the execute method on that use case.  It's just that now we do those three things  from three different isolated locations.  Back in Episode 7, we explored the employee data model once before.  Here it is again.  And again, notice how it used the open-close principle  to separate the concerns.  We separated the pay disposition, the pay type, the pay schedule,  membership. And these things can all be separately extended through their own  derivatives without having to be modified. This isolates the employee and  all of its clients from being recompiled or redeployed whenever any of these  extensions take place. Notice how conformance to the open-close principle  improves conformance to the single responsibility principle. We've been able  to separate these modules now so that there are modules that serve the union  Consider the add time card use case.  The use case is pretty simple.  It has to fetch the employee from the employee gateway, then it has to create a time card,  But if you think about it, there's something kind of tricky going on here.  How does this use case know that the pay type object held by the employee is an hourly pay type?  What method does the use case call to add that time card?  So here's one possibility.  is passed a request object. We have to cast that request object into an  add time card request. Now we can build the time card from the data that's in  that request  data structure. We can also fetch the employee from the employee  gateway using the employee ID that's  in that data structure. And then  we ask the employee to add the time card.  What don't we like about this solution?  Why in perdition and tarnation should that there employee class know anything about that consign time card?  Why that for sure violates the open-close principle.  Because now every time you got a pay type that's got some cotton-picking data element in it,  you're gonna have to put some add method in that employee class.  You'll never be able to close that class, son.  to add put add methods in there every time there's some new pay type burn that idea son burn it hot  and burn it long no good will come of it if you leave it the way it is okay well then what if we  add the add time card method to the pay type interface that solves the open close principle  the hourly derivative can add the time card, but the salaried and commissioned derivatives could just ignore it.  What do we think about that solution?  Well, that'll work just fine in Ruby, won't it? But this here ain't Ruby. This here's Java!  Son, sometimes I wonder if you got the sense that God gave a horse.  about the time card when you put a method in an interface that doesn't  apply to all the derivatives you're violating the Liskov substitution  principle and you are brewing one smelly kettle of fish okay then how about this  let's just get the pay type object out of the employee cast that pay type  object to an hourly pay type and then call add time card on the hourly pay  What do you think of that?  That's the ticket there son, that's the ticket!  That there pay type has just got to be an hourly,  cause it came out of an end time card request,  and that request is just sure gonna have an hourly employee in it.  So that cast there, it tells the God's own truth.  I tell you what son, when a cast tells the truth,  that there's a fine cast indeed.  that the Liskov substitution principle would force us to do a downcast?  But actually that kind of thing is pretty common.  After all, we don't want to pollute the base class interface  with methods that are specific to one particular derivative.  When you know that you are holding a particular derivative,  there's no harm in downcasting to it.  We can also see the Liskov substitution principle  at work in the other business objects within the system.  the pay schedule. The derivatives of pay disposition simply send the employees pay wherever it's  supposed to go. The derivatives of pay schedule all answer the question, is today payday?  These subclasses are all orthogonal, but they're also all substitutable. The union membership  interface is something of a special case. There's no doubt about what the member derivative  and service charges as we would expect.  But what does the non-member derivative do?  Well, the answer to that is that the non-member derivative does nothing.  It implements the methods of union membership  to do exactly the right kind of nothing.  Now, I can see some of you guys out there are raising your eyebrows over this one.  Isn't that a symptom of a Liskov substitution violation?  Well, yeah, it is, usually.  But there's a special case.  And the special case is when all of the methods of a derivative do nothing.  Then you've got something called the null object pattern, which is a pattern that we're  going to be discussing in a later episode.  In this case, the non-member derivative does nothing in every method that gets called.  to do for service charges.  Remember this? This was our solution to the open-close principle violation.  Unfortunately, it leads to an interface segregation principle violation.  Consider the request builder. It has methods in it for each of the request data structures.  the use cases. And that means that the addEmployee controller is going to  depend upon methods that it does not call. In other words, it knows too much.  Now look what happens when we add more controllers. The fanion on the request  builder and the use case factory grows. Each one of those controllers depends on  So as we add more and more controllers, the fan-in on those objects grows without bound.  Clearly, this much fan-in is a problem. It leads to some really nasty issues.  For example, every time we modify a request or add a new request, or every time we modify or add a new use case,  we're going to have to recompile all the controllers, because we have to add methods to those interfaces.  compile and redeploy all the controllers, we thrash the system. This is that strange reverse  dependency that comes from too much knowledge. We could solve this problem by using a dynamic  language like Ruby, or by using a dynamic interface for the request builder in the use case factory.  Imagine that we took the use case factory and we took out all those make methods and replaced them  took a string. You'd pass in the name of the use case to that make method, and the implementation  of the factory would look at the string and decide which use case to return to you. The request  builder could use a similar approach. We could get rid of all of those build methods in the request  builder, and instead we could pass in a string and a hash map. The string would contain the identity  contain all the constructor arguments. This means we lose type safety. We can  fix the type safety issue, but only by adding a bazillion new interfaces. Each  of these interfaces declares only those methods that the particular controller  that uses it calls. This looks messy. Actually, it's not quite as bad as it  looks, though, because these interfaces are small and they contain no  These two design choices you choose depends on how tied you are to static typing and how  much you trust your unit tests.  The dynamic method works perfectly well, it's not particularly inefficient, and as long  as you've got a good suite of unit tests to protect you from type errors, you really aren't  losing anything.  On the other hand, if you're really paranoid about types and you don't trust your unit  Of course, we've been using the dependency inversion principle throughout this design.  We've been inserting interfaces and inverting dependencies across those boundaries throughout.  But the dependency inversion principle has a specific connotation.  It says high-level policy should be independent of low-level detail.  connotation of the dependency inversion principle. Take a look at this code. We've  seen this code before in episode 7. It is the algorithm for paying an employee and  it's a very simple algorithm. For each employee, if today is when he should be  paid, then we will calculate that pay, deduct union dues and service charges,  And yet, look at this algorithm.  It says nothing about hourly, commissioned, salary, weekly, bi-weekly, monthly, addresses, union memberships, non-union memberships, direct deposit, or paymasters.  The algorithm is the truth.  It's the utter truth.  And yet, it's completely independent of all the low-level details that complicate the payroll application.  to this code that's hard to fathom. It's simple, yet it affords endless complexity. It has an  elegance that hides all distractions. It says it all without admitting of any detail. It's true,  and yet it doesn't equivocate about exceptions or special cases. It says what's true.  And so that's SOLID. We've looked at the SOLID principles now from top to bottom and side to  side. We started with an overview, we looked at each principle in depth, and we ended with this  case study about the payroll system. If you followed all these episodes, you should now  into the issues of software design. But now that you know these principles, how do you use them?  Are they laws? Are they rules? Or are they more like guidelines? Each principle illuminates a  particular software design issue. Each principle gives you the context for making a decision. You  Indeed, there are times when you should utterly ignore the principle.  However, you should know that you're ignoring it.  When you ignore a principle, you should know what principle you're ignoring,  and you should have made the decision to ignore it.  As an example of the wrong attitude to take towards these principles,  allow me to quote Joel Spolsky in an interview he gave  Flow podcast number 38.  So here are Jill's words.  Last week, I was listening to a podcast on Hansel Minutes with  Robert Martin talking about the solid principles. That's a  really easy to Google term. It's object oriented design, and  they're calling it agile design, which it really, really isn't.  of the Agile Manifesto and called the meeting  that created it, I think I can say Joel is wrong about that.  It's principles for how to design your classes  and how they should work.  And when I was listening to them,  they all sounded to me like extremely bureaucratic  programming that came from the mind of somebody  that has not written a lot of code, frankly.  who doesn't have a chance to respond.  But just to give you one example,  a part of the SOLID principles was that  if you write a class, that class has contracts  with all the other class that it interacts with,  and those contracts should be expressed in interfaces.  So you shouldn't just interact with the class  because that class may change.  If you have a particular class that you need to use,  you should make a custom interface  for just what you're going to use in that class.  has to change and the interface is the only thing that you have to pound include clearly he was  talking about the interface segregation principle here does that make sense so you've got some class  with 40 different little methods on it and i'm only going to use six of them so i should make  an interface with those six things that i can use and the class will implement that interface and  that's my contract with the class that those are the only six things i'm going to use  people that say things like this have just never written a heck of a lot of  code because what they're doing is spending an enormous amount of time  writing a lot of extra code a lot of verbiage a lot of files and a million  little classes that don't do anything and thousands of little interface  classes and lots of robustness to make each of these classes individually armed  to go out into the world alone and do things and you're not going to need it  You're spending a lot of time in advance writing code that's just not going to be relevant.  It's not going to be important.  It could theoretically protect you against things, but how about waiting until those  things happen before you protect yourself against them?  But don't worry, I did get my say.  I went on Stack Overflow podcast number 41, and Joel and I kissed and made up.  Fascinating.  The point is that it's easy to look at the solid principles and get the wrong idea about them the way Joel did.  No design is fully solid compliant.  No design should be fully solid compliant.  In fact, full solid compliance is an oxymoron.  The principles illuminate design issues and recommend solutions, but they don't prescribe behavior.  So use this new knowledge to your benefit.  Be an engineer.  Allow these principles to help you make trade-offs and compromises.  Don't be a slave to these principles or any principles.  Respect them.  Don't bow to them.  And so we've come to the end of this episode and of this series on the solid principles.  I hope you've learned something.  I hope you enjoyed yourself.  to talk about. I mean there's the component principles, there's design patterns, there's  agile practices, there's advanced testing, there's professionalism. You're not going  to want to miss the next exciting episode of Clean Code, episode 14, the component principles.  You may have noticed that this episode is a little bit different from other episodes.  we're gonna go back to the old format. I just wanted to do this one a little bit  differently because it was a serious case study and I wanted to draw your  attention fully. Next episode back to normal. For some definition of the word  normal anyway.  We'll be right back.  We'll be right back.  We'll be right back.  So when would I draw diagrams this detailed and this complete?  Well, you're seeing it right now.  I would draw diagrams this elaborate  Remember this? This was our solution to the open-close principle.  I... open-close principle...  I was wondering when these were going to start happening.  Yes, yes. Well...  We haven't had any yet.  Yes, yes. I know, I know.  We mean no harm to your planet. We mean no harm to your planet.  Okay.  Joel's world here's Joel's world okay you want to go to Joel's world I'm gonna  go to Joel's world I don't think you'd like it there smells bad yes okay okay  That was a good meeting too.  Why in perdition and tarnation would you have a nose on your face?  Yeah. 