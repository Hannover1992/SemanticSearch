 ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത്ത�  Hi, I'm Amanda.  Hi, I'm Samantha.  Hi, I'm Alexis.  Hi, I'm Laura.  Welcome to another episode of  Clean Code.  Clean Code.  Clean Code.  Your best entertainment journey  to begin  In this episode...  By Uncle Bob.  Uncle Bob.  Enjoy.  Uncle Bob.  Uncle Bob.  Welcome, welcome to episode 17 of Clean Code.  component coupling. Here, let me take that hat.  Remember last time we talked about component  cohesion. Those are the forces that glue classes  together into components. And we also talked a fair bit about  the forces of false cohesion that impede independent  deployability. Then we talked about the release-reuse  equivalence principle, which told us that the granule  granule of release. After that, we talked about the common closure principle, which told us that  we construct components by gathering together classes that change for the same reasons,  but keeping apart classes that change for different reasons. Then it was on to the common  reuse principle, which reminded us once again of the problems of too much knowledge. It told us to  When you used a component, you used all of the classes within a component.  And then Albert got on the scene,  and Albert talked to us about how these principles are mutually exclusive,  and how early in a project you'll favor those that support developability,  but later on in a project you'll probably favor those that support reuse.  component coupling, the forces that bind components together into systems.  And we're going to talk about three principles, the acyclic dependencies principle, the stable  dependencies principle, and the stable abstractions principle.  We'll talk about the strange disease called the morning after syndrome, which takes place  in large teams as they step all over each other trying to develop a system because of  We'll talk about the two solutions that have been found to this problem.  They were discovered in the 60s.  Then we're going to talk about stability.  What is stability?  How do you measure it?  And how does it glue components together into a dependency structure?  And then after that, we're going to talk about the interesting relationship between stability  provides an escape clause from rigid systems.  And after we've done all of that, well then, we're going to talk about metrics.  We're going to discuss a numerical mechanism for determining the quality of our component  designs.  Proceed immediately to your DC stations and activate your inertial dampers.  beta decay. We're going to slingshot through the barrier of component coupling.  When you look at yourself in the mirror, you see yourself in mirror image. But what does  Usually we think of this as a left-right reversal.  After all, words appear backwards, letters appear reversed,  our hair seems to be parted on the wrong side.  Actually, there is no left-right reversal,  and I can prove that by pointing to the left.  And notice that my reflection is pointing the same direction that I'm pointing,  to the left.  Or I could point to the right,  in the same direction there is no left-right reversal interesting question isn't it what  is reversed in a mirror if not left and right now I brought two signs with me one points to  the right one points to the left and if I turn and put them in the mirror well you can see that  Front to back.  Not left to right, but front to back.  Now, you can see in the mirror, those arrows are pointing in the right direction.  You can even read the words.  That was done through a front to back reversal.  Now, look at me.  I am facing my own reflection.  My front is facing my reflection's front.  That is a front to back reversal, not a left and right reversal.  do not invert left and right.  They invert front and back.  Now let's say that there were two worlds,  ours, and one that was a mirror image of ours.  Is there any experiment that you could perform  that would tell you which of these two worlds you were in?  If you think about this for a bit,  the realization that the answer is no. Any experiment you perform in the mirror world  will have precisely the same results as the corresponding experiment in our world.  Indeed, even if you were speaking on the phone to someone in another place, there is no experiment  the two of you could jointly perform that could tell you which world the two of you  For example, you could try to ask the person on the phone what direction his watch was  moving, but he's going to tell you that it's moving in the clockwise direction, regardless  of which world he's in, because no matter what, it looks clockwise to the guy who's  watching that watch.  Physicists call this inability to tell which side of the mirror you are on the symmetry  And indeed, the symmetry of parity is a fundamental law of physics.  No it ain't.  No it ain't.  Leastways not since 1934, see, cause that's when all the rules changed.  Let me tell you this story, son.  I use it to put my mule to sleep.  See it all started back in 1896 with a fella by the name of Becquerel.  of radioactivity when he noticed the fogging of photographic plates?  Three years later, in 1899, Ernest Rutherford discovered that there was more than one kind of radiation.  He called the first kind alpha rays. They couldn't even penetrate one sheet of paper.  But the kind that could penetrate many sheets of paper he called beta rays.  a third kind of radiation, which Rutherford named the gamma ray. It could pass through  blocks of wood, but was stopped by metals like iron or lead.  That same year, Becquerel measured the mass to charge ratio of the beta rays and found  them to be identical to electrons.  showed that alpha and beta particles were emitted when an atom of one element was transmuted  to an atom of another element.  Yeah, and then 12 years later, Sadi and Casimir Vajant showed that when an atom emits an alpha  particle, it transmutes two elements to the left.  In 1911, Lise Meitner and Otto Hahn showed that the beta ray, the electron, emitted by an atom  that is transmuting one place to the right did not have enough energy. Indeed, this missing energy was  a huge problem. Meitner and Hahn knew the energy that ought to be emitted when an atom transmutes,  did not carry that energy.  Where did the energy go?  Nobody knew.  And so the situation remained for 19 years.  It was a deeply disturbing puzzle.  But then, in 1930,  out of sheer desperation,  Wolfgang Pauli suggested  that maybe some neutral, undetectable particle  was carrying the missing energy away.  fella by the name of Enrico Fermi and he thought this was a crackerjack of an idea. He named that  particle the Neutrino, which means little neutral one. That reminds me of my...never mind what that  reminds me of. Okay, well, in 1934 Fermi came up with a model for beta decay. He said that a neutron  decay into a proton, an electron, a beta ray, and a neutrino.  So if you measure the spin of the neutrino as it is moving away from you, you will see  that it is always spinning clockwise, every time, no exceptions, clockwise.  But, if you ask your reflection to do the same experiment and have him tell you what  neutrino is spinning, he will tell you that the neutrino is spinning counterclockwise.  So that there law of symmetry of parity ain't worth all them highfalutin syllables is it?  Cause it ain't right. There ain't no law of the symmetry of parity.  Indeed.  that we can tell what side of the mirror we live on is a fact so profound that other facts  pale in comparison. For with that fact comes another. A fact that we will explore in a  future episode. A fact that provides the answer to the question, why are we here?  Have you ever worked all day to get your stuff working and then gone home at night thinking  everything was fine? You come back the next morning and all your stuff is broken. And you know why?  Because somebody stayed later than you and changed something that you depend upon. So  you work all day to get your stuff working again and you come home  again. We call this the the morning after syndrome. This is a chronic condition  caused by attempting to use large teams with inappropriate development processes.  Historically there have been two treatment options for this condition. The  I've done that before. It's really easy.  Everybody just checks out their code on Monday and they do anything they want with it.  And then on Friday we just all get together and integrate.  Yeah, I've done that too.  And it works okay.  Except every once in a while you get on a project where Friday's not enough.  And then you have to work on a Saturday.  And that's just not fun.  Oh yeah man, I mean, I think we were doing that at Farsbrook or Goopon.  I don't remember, but I do remember that we'd start integrating on Friday, but dude, Friday  was like never enough.  And then we'd have to integrate on Saturday, and that's a bummer.  So then we just gave up and started integrating on Thursday.  to us over at overcal except even thursday wasn't enough after a while so we started integrating on  wednesday yeah i was working in redmond once where we were integrating every week but we finally had  to give up on that and start integrating every two weeks oh dude that's just so weird like the same  was it five round? I don't remember. But I do remember that we pushed all that integration out  to two weeks. But then that wasn't enough because we were integrating the whole second week. So we  finally just pushed the integration out to once a month. Whoa. So I think you get the idea. I mean,  the weekly build is fine as long as Friday is sufficient for integration. But as teams grow  get larger Friday is no longer sufficient and then you grow your cycle to a bi-weekly build  and eventually even a monthly build many years ago many years ago I consulted for a Canadian  telecommunications company and they had gotten the problem they had started their system with  and they wound up suffering with a two-week development cycle and a two-week integration cycle.  So they solved that problem by using the second primary solution to the morning-after syndrome.  They spent about three months re-architecting their software to conform to the acyclic dependencies principle.  The acyclic dependencies principle says this.  The software system is composed of components, and the dependencies between those components  must not form a cycle.  That is, if you start at a component and follow the dependencies, you must not wind up back  at that original component.  The result of this is that the dependency structure of the components forms a directed  acyclic graph.  all those fancy university words is that the arrows you draw between your components ought  to never go in a circle like a rattlesnake swallowing its tail i often verify this by  simply drawing the component graph and making sure all the arrows point in a downwards direction  if all the arrows are pointing down there can't be any cycles  problems. Consider this component diagram. Notice that all the arrows are pointing down so there's  no cycles. Now I want you to imagine that each component is being developed by its own team,  and the team that's developing the alarm component down there at the bottom is just about to make its  it's the teams who are developing the elevator and conveyor components.  And the procedure is very simple.  The alarm team makes its 1.0 release,  and then they move that component to some convenient place  where the elevator and conveyor teams can get at it.  And of course this means that the alarm team can begin to work on its 1.1 release,  while the elevator and conveyor teams continue to work on their 1.0 releases.  independently because the components themselves are independently developable.  Clearly, since the elevator and conveyor teams are both using the 1.0 release of alarm,  the alarm team is free to make any changes it wishes in pursuit of its 1.1 release without  affecting elevator or conveyor. There is no morning-after syndrome. And this independent  continues on up the diagram.  Conveyors and elevators can make their 1.0 release  and then start working on their 1.1 independently.  Transport can make its 1.0 release  and then start working on 1.1 independently.  All the teams can work independently of each other.  Of course this means that each release  will travel up the diagram like a wave,  management. And in fact, that's not even realistic, because in reality, component teams will often  join together to develop things at the same time. For example, Alarm and Elevator might decide to  work together for a few weeks on a common release, but they're always free to break that coalition  anytime they want, because the components themselves remain independently developable.  So now let me tell you the story of some poor schmuck who, in 1989, while working at Rational  on the first release of ROSE, haplessly created a cycle in the dependency graph of that system.  He was the responsible programmer for the error management component that sat down at  Now the UI component was way up at the top of the diagram.  It turns out there was a class up in the UI,  and that class had a method called display.  So you know what he did then, K-9?  He called it.  The fool! The blithering idiot!  God help him now!  Well, it wasn't God who helped me, at least not quite.  But to me, at that time, it almost might have been because it turned out the guy who helped me was Grady Booch.  Bob, Bob, Bob, I do hope you're not planning on putting cycles in your system.  Remember that time that back in the early rational days I had you sit down with Dave and I think I even flew out to take you behind the woodshed?  Never a good idea.  Layers, Bob. Layers.  And I needed the help too.  You see, the day after I did that, a lot of the developers on the ROSE team came to my cubicle with clubs.  In fact, by creating that cycle, I had made the entire system unreleasable.  In fact, I'd made it unbuildable.  So here's that cycle.  1.2. What do they need? Well, they need error management's 1.2. But error management needs UI  1.2, which needs projections 1.2, which needs semantics 1.2, which is the component we're  trying to release. And so now, of course, all those teams will have to work together on the  the morning after syndrome. Disgusting! But that's not the worst part. The poor semantics  team has suddenly found themselves dependent on the persistence component. They don't want it,  they don't need it, but they've got a transitive dependency on it. But the persistence component  is broken and it's going to stay broken for several weeks and so the semantics team is  to a persistence component that they don't need.  Decidedly suboptimal.  But things are actually a lot worse than that. You see,  there's no valid build order for the system.  Remember that in statically typed languages, compilers have to build  from the bottom up. But if there's a cycle of dependencies,  there's no bottom. There's no correct build order.  is undefined.  Ha ha ha!  Well, that's so cool! That must be why I have to  build my systems two or three times in order to  get them to work! Ha ha ha ha!  Very likely.  Ha ha!  Visual Studio doesn't  allow cycles between projects,  so we don't have that problem!  Ha ha ha!  Indeed. One of the  few good things to come out of that tool.  Oh man, that's such a drag for you.  Don't look so smug, Ruby.  You still need to deal with the cycles, even if build order isn't a big issue for you.  Bummer, man. Bummer.  So what do you do if you find yourself with a cycle?  And you will.  this problem. The first approach is very simple. Just split the component that's the target of the  dependency into two components. In the error management case, we could have taken that display  class that was up in the UI and pulled it out into a wholly different component that both UI and error  management would depend upon. Splitting components sounds risky. If you keep doing it, you'll wind up  True! And so the other approach is to use the dependency inversion principle. We find the  dependency that causes the cycle and we invert it. In this case what we could do is create an  interface for displaying messages. We could have that interface reside in the error management  In this case, the solution is simple, so this principle can always be followed.  In order to avoid the morning after syndrome, just keep all the cycles out of the component dependency graph.  Which would you rather depend upon? A component that's stable, or one that is unstable?  That's a silly question. Clearly you want to depend upon a component that's stable.  But why?  So to answer that we need to define what stability is.  So, is that pen stable?  Yet it would be inappropriate to claim that it is instable, since it is not falling over.  An interesting dilemma.  The correct answer is that the pen is not very stable.  You see, stability is not a Boolean attribute.  Things are not either stable or unstable.  They are partially stable.  This pen is not very stable because it doesn't take a lot of work to upset it.  On the other hand, this counter is very stable because it would take a tremendous amount  of effort to change its state.  So something that's hard to change is stable and something that's easy to change is unstable.  So what would you rather depend upon?  unstable.  It's perfectly obvious that if you're going to depend upon something you want it to be something that's hard to change.  After all, if it changes that means more work for you.  So you depend on something that is so hard for someone else to change that you can be sure that it will hurt them  more than it hurts you.  of change. When someone changes something you depend upon, make sure it hurts them more  than it hurts you. And so the stable dependencies principle says that a component should only  depend on other components that are more stable than it is. Or, to say this a different way,  all the dependencies in a component architecture should be pointing in the direction of increasing  Ok, but how do you know what makes a component stable?  I mean, a component could be hard to change because it's badly written or really complicated  or just really, really big.  So what is it that makes a component stable?  Pure dependency.  Spock's right.  It's all about the dependencies.  then the only thing left are the dependencies between the components.  Consider the component named S in this diagram.  It's got lots of incoming dependencies.  Lots of other components depend upon it.  Is it stable or instable?  Well, of course it's stable, you ninny.  If you have to modify it in any way,  you're going to have to check all the other components that depend upon it  you've broken any of them and that's going to be hard to do and so something that's hard to do  makes it hard to change and that means it's stable that's right component s is stable because any  change we make to it is likely to affect all those dependent components so component s is stable  so now what do you think of component i it's got lots of outgoing dependencies on other components  Well now son, it's as plain as the nose on your face that that there component eye is  as stable as a two-legged mule.  I mean, there's nothing stopping it from changing, no incoming dependencies to make it hold still,  and there's all those outgoing dependencies that are likely to make it change.  Boy, this thing is easy to change and it's likely to change.  It's instable.  Right again, component I is definitely instable.  It's got all those outgoing dependencies that are likely to force it to change,  and it's got no incoming dependencies to keep it from changing.  Component I is instable.  Well, now let's look at component S again.  See all those incoming dependencies?  We say that component S is responsible to all those components out there that are depending upon it.  component S doesn't depend on anything else, so it's independent. Component S is  responsible and independent. Component S is an adult. So now let's look at  component I. See all those outgoing dependencies? Component I depends upon a  lot of other components, so it's dependent. On the other hand, nobody  dependent and irresponsible.  Component I is a teenager.  So now let's look at one particular teenager  which I've called EZ.  I've called it EZ because the intention is  that it'll be easy to change.  Whoa, man, dude.  Like, do you really wanna make a component that instable?  On the contrary, we want certain components to be instable, because in those components  we would put the code that we expect to change frequently.  Right! Anything you put into a stable component is going to be hard to change.  So if you've got something you want to change frequently, put it into an instable component like EZ.  Now let's look at another component named H.  those incoming dependencies. H is stable. H is an adult. H is hard to change. But now  watch what happens as this evil programmer modifies H and causes it to mention EZ's  It is the perversity of software that someone else can completely ruin the maintenance characteristics  of your component simply by mentioning its name.  And that's why we don't want adults depending on teenagers. All instable components should  depend upon more stable components. All the arrows should be pointing in the direction  Okay, but you still haven't told us how we compare the stability of components.  How do we know which components are more stable than others?  I think we need a number.  Ja, ja, ja, we need a number, we need a number.  And how can we get that number?  the components. Here in this diagram you can see there are components and classes  inside those components. Now look at the component C. Let us say we want to know  the stability of component C. We can count the number of classes outside of C  that depend on classes inside of C. We will call this number afferent couplings,  count three. So the afferent couplings of C are three. I tell you that fella's gonna blow his  brains clear out of his ears if he keeps using those high and mighty words. Afferent couplings?  Afferent couplings? What the hell is that? Sounds like some kind of nervous disorder in trains.  at C is 3. The next thing we are going to count is the number of classes outside of  C that classes within C depend upon. We will call this number the afferent couplings, CE.  And we count 2. I pray that the good Lord saves us from smart people at Blackboards.  nice simple phrase like fan out when you can use some really complicated sounding  set of words like afferent couplings for crying out loud son this is a fan out  fan out it's the fan out of C. Yeah and so next we take the ratio of the  afferent couplings CE to the sum of the afferent and efferent couplings CA plus  which we shall call i for instability.  The number i will be zero in the case where it's very stable,  and the number i will be a one in the case where it's very instable.  In our case, the number i is, see, two divided by five.  It's two fifths.  I mean, who can make any sense out of all of these I's and C's and A's and ratios?  Son, this is simple.  Look at this here cipher now.  Now, if you've got a component and it's got a bunch of fan in but no fan out, well then  that's a stable adult, son, and that I metric's gonna be zero.  On the other hand, if you've got a component that's got a load of fan out but no fan in,  Major, son, it's got an I metric of one.  I believe that's what I said.  Son, you got a lot to learn about making things simple for people to understand.  But tell me this, Albert, old boy, I mean, why'd you call that metric I?  Why didn't you call it S for stability?  You could have jiggered around with that there formula and made that S a one for stable and zero for unstable.  Why'd you have to go and make it I?  Ah, yes, yes, that's a very good question.  You see, the I-metric is far more convenient later on  than we do the abstraction analysis and compute the optimal distance factor.  Never mind there, Albert, old son, never mind.  I don't want to hear it, neither do the good folks out there.  Gee, hosafat!  the I metric, the instability metric.  And now we can redefine the stable dependencies principle  to say that the component that is the source of a dependency  should have a higher I metric  than the component that's the target of a dependency.  Or to say that a different way,  all the dependency arrows should point in the direction of decreasing I.  And if you look at our EZ and H problem, you can see that H, because it only had incoming  dependencies, had an I metric of zero.  And EZ, with no dependencies, had an I metric of one.  And so the evil programmer who hung the dependency from H onto EZ caused us to depend in the  direction of increasing I, violating the principle.  Yeah, that's cool.  But what do you do?  already got components that depend in the wrong direction like I do. How do you fix that?  You fix  it the same way you break a cycle in the dependency graph. You either  split the component or you use dependency inversion.  Look, the reason that the evil programmer  hung that dependency from H onto EZ was because  there was some class in EZ that H needed to call.  can pull it out and put it into its own component, which we will call n. And then, of course,  EZ will depend on n, and H will depend on n. And that gives EZ an I metric of 1, and  n an I metric of 0. And H has an I metric that is not quite 0, a little bit off 0, but  still pretty low. And so all of the dependencies are pointing in the direction of decreasing.  I. Or we could create an interface up here in H and have some class down here in EZ implement  that interface. And that would give H an I metric of 0 and EZ would have an I metric of 1.  And all the dependencies would be pointing in the direction of decreasing I.  It's not hard to make sure that your component dependency structure is aligned to stability.  And when you do, you will ensure that those components that you planned on being easy to change  remain easy to change.  Gosh, Uncle Bob, what about all those adult components down there at the bottom of the dependency graph?  I mean, they're really stable, aren't they?  That makes them really hard to change, doesn't it?  Well, no, it's not good. In fact, it's very, very bad. It's so bad we're going to have to do  something about it because we can't leave all those components at the bottom down there difficult  to change. It'll make our system inflexible. But it turns out that there is something we can do about  Ah, the open-close principle.  The open-closed principle.  Indeed, Captain, a module that is closed for modification may still be open for extension.  And that's the key to it.  There's no way to avoid all those adult components down there at the bottom of the dependency structure.  They're going to be down there. They're going to be hard to change.  if we design them correctly.  Even though they're closed for modification,  we can make sure they're open for extension.  And do you remember how, back in episode 10,  we learned how to create software  that conforms to the open-close principle?  Well, do you?  It's abstraction, abstraction.  That's how you conform to the open-close principle.  It's the abstract classes that are open for extension,  they might be closed for modification.  And so we have our final principle, the stable abstractions principle, which says that the  more stable a component is, the more abstract it should be.  So all those stable adults down there at the bottom of that there dependency graph, they  should be as abstract as the sun on a rainy day.  unstable teenagers up there at the top of the dependency graph why they should be as concrete  as a month old cow pie of course all this stuff makes perfect sense when you think about it  the concrete stuff goes up at the top where it's very unstable and easy to change and it's likely  to change concrete stuff is likely to change all the abstract classes and interfaces go at the  always change so much.  But wait a minute Uncle Bob, you said that a component should be as abstract as it is  stable, but you said stability is not Boolean.  Your I-metric goes from 0 to 1 and can take any value in between, but isn't abstractness  Boolean?  I mean, a class is either abstract or not.  A component is comprised of many classes.  Some of them will be abstract, some of them will be concrete, and we can find the abstractness  of the component by taking the ratio of them.  Indeed, the abstractness of a component is the simple ratio of the number of abstract  classes in that component to the total number of classes in that component.  It is a number which goes from zero to one.  Give this a try.  Let's say you've got a component with ten classes in it, and three of them are interfaces,  totally abstract, and two more are abstract classes.  That's five, son.  One half of the total.  Fifty percent.  Zero point five.  Even Steven.  Capiche?  Whoa, man!  Wow! But look, man, how do you make sure your components are as abstract as they are stable?  A plus I equals 1, right? I mean, consider an adult. I is 0, A is 1, they add up to 1.  Or if you'd rather, think about it this way.  The bigger A gets, the smaller I gets.  The bigger I gets, the smaller A gets.  But no matter what, they always add up to one.  Cool.  You really do that?  Yeah.  Well, no.  Well, look.  really familiar with it, well then I can visualize this. I know that the stuff at the top is concrete,  I know that the stuff at the bottom is abstract. I don't have to work the numbers because I'm in  the system, I can feel it. On the other hand, if I'm called in to audit a system, well I'm  unfamiliar with that system. So yeah, I'm gonna work the numbers and those numbers will tell me  and point me in the most likely direction about where to begin.  Consider what it means if A plus I is not equal to 1.  It either means that there's a whole bunch of concrete classes  with lots of incoming dependencies,  or a whole bunch of abstract classes with no incoming dependencies.  And in either case, that's a violation of the dependency inversion principle.  when we learned about the dependency inversion principle?  That principle told us that dependencies should point towards abstractions  and not towards concretions.  Do you remember that?  And so the stable abstractions principle,  a plus i equals 1,  is a numeric indication of how well your component structure  adheres to the dependency inversion principle.  Now I want you to look at this diagram.  It is a plot of abstractness versus instability, A versus I.  Abstractness is on the vertical axis.  Instability is on the horizontal axis.  Now look at the upper left corner.  That's the place where all the adults are.  These are the two extreme positions where A plus I equals one.  But what are the other two corners?  Well now buckle that top right corner's a weirdo.  Cause up there you got abstract classes we ain't got nothin' dependin' on them.  And that's about as useful as Chanel number five outta Polecat.  I don't wanna see any components goin' up towards that corner.  of uselessness. The zone of uselessness. The zone of uselessness. That upper right  corner is a bunch of abstract classes and interfaces that nobody depends upon,  nobody implements. Useless. But if that's the zone of uselessness, what do you  think the lower left corner is? That's a bunch of concrete components that lots  upon. What would you call that? That's the zone of pain! Yes, pain. Think of what's down here.  Things like database schemas. Concrete, heavily dependent upon, fun to change. We don't want our  Of course not everything in that corner is painful.  String and vector, for example, they live in that corner.  They are not painful because they are not changing.  You see, there's another axis on this graph.  It is the axis of volatility  which comes out from the screen and points towards you.  Well, there he goes again with all that highfalutin jargon  about axes and volatilities and all that stuff.  Look, what he's trying to say is that we aren't worried about library components that ain't  changing, we're worried about the ones that are changing.  Those components that are changing that we're developing right now, we don't want them heading  down towards that corner of pain, son.  Keep those ones we're changing now away from there.  So we'd like to keep all our components as far away from those bad corners as we can  get them.  That means they're going to fall on this line where a plus i equals 1.  And that keeps them as far away from the bad corners as they can get.  I call that line the main sequence.  And so what do we do with a component that is not on the main sequence?  How can we evaluate it?  We can measure its distance from the main sequence.  called d for distance, and it is the absolute value of a plus i minus 1. This  is a metric that goes from 0 to 1, where 0 is right on the main sequence, and 1 is  as far from the main sequence as you can get. Fascinating. A single numerical  indicator of the dependency inversion principle. I imagine that could prove to  Yeah, in some cases it certainly can.  You can track all the D-metrics for all of your components over time.  And if those metrics veer away from zero,  well, then you know some kind of rot is building up in those components.  Either there are concrete classes that are attracting more and more dependencies,  or there are abstract classes that don't have enough.  Or you can plot all your components on the AI graph  statistical deviations. Something is probably bad if some component is lying  two sigma away from the mean. But in reality I don't calculate these metrics  on a regular basis. As long as I'm familiar with the system I can feel  whether they're in balance or not. But in systems where I'm not familiar with it  then these metrics can come in pretty handy. They can point me in the right  Great!  So that's it. Those are the component principles.  Now let's look back on them and see how far we've come.  In episode 15, we learned of the history and nature of components.  And then we learned that a software system should be composed of a plug-in structure  components.  And then in episode 16 we learned the three principles of component cohesion.  They told us which classes belong together into components and which classes we should  separate into different components.  In this episode we learned of the three principles of component coupling.  The acyclic dependencies principle, the stable dependencies principle, and the stable abstractions  The acyclic dependencies principle told us that in order to avoid the morning after syndrome  and create systems that are both releasable and buildable, the dependency structure of  the components must form a directed acyclic graph.  The stable dependencies principle told us that components are hard to change because  increasing stability. Finally, the stable abstractions principle told us that our  components should be as abstract as they are stable. Yeah, and like man we learned so much  stuff and so many numbers man and graph like thingies but but like how do you use all of this?  But just think what we've learned over the last 17 episodes.  From function structure to test-driven development,  from architecture to object-oriented design,  from comments to components.  Well, you know what this means, right?  It means we're done with this episode, ready to walk the dogs.  But you know what?  need to put all this together. It's time for us to write an application. Now, I know we've got a  whole bunch of other stuff to talk about. We've got advanced test-driven development. We've got  loads and loads of design patterns. We've got acceptance testing, professionalism, functional  programming. The list is daunting. But before we get to that list, we're going to do a component  case study. So you're not going to want to miss the next exciting episode of Clean Code, episode 18.  the component case study.  Come on you dogs, let's go.  Time to go for a walk, dogs.  No tricks to you.  You can't go out without being carried  because your knee still hurts.  All right, dogs, let's go, let's go.  Come on.  All right, we're past the stairs.  Now you can go down.  We'll be right back.  We'll be right back.  We'll be right back.  The granule of release is the granule of reuse.  Or the other way around.  Depending on which way you want to say it while somebody's walking backwards down the stairs.  Welcome!  Action!  God damn it, go away!  You talk about data decay.  Data decay?  Data is going to decay?  Heavens!  Beta decay?  Consider that...  Consider...  Imagine...  Imagine...  Imagine...  there's no people no that's not what he said anyway dependencies to keep it from  changing and it's got lots of doorbells ringing that will make it change a lot  right again component I is definitely stable stable no it's in stable action  Yeah.  I mean, dependencies.  And EZ had no dependencies at all.  Depend...  I can say the word dependency.  I can't.  Dependency, dependency, dependency, dependency.  I can say that.  Well, and if you look at our EZ and H problem,  why, you can see that H has...  Gosh, this is so exciting.  Action!  Alright, yeah.  Oh wow man bogus man imagine imagine that this component was like the whole world and  inside it we're like people Wow so far out 